export class ReplayInfoParser {
  #matchData;
  #playersLost; // optional
  #timeLine; // optional //TBD
  #stats; // optional //TBD
  #researches; // optional
  #initData;
  #start;
  #version;
  #scriptParameters;
  #researchesContext;

  // generated structures
  #factionTeams; 
  #playerSurvival; // optional
  #playerWinners; // optional
  #teamWinners; // optional
  #winnerSurvivalTime; // optional
  #isWonderWin;
  
  constructor(researchesContext) {
    this.#researchesContext = researchesContext;
  }

  parse(replayApiResponse) {
    if (replayApiResponse.error === 2) {
      return {
        error: replayApiResponse.error,
        message: 'Replay does not exist.'
      };
    }
    if (replayApiResponse.error === 6) {
      return {
        error: replayApiResponse.error,
        message: 'War Selection API is unavailable due to the server maintenance. ' +
        'It can last up to several hours before endpoint will be available again. Please, try later'
      };
    }
    if (replayApiResponse.error !== 0) {
      return {
        error: replayApiResponse.error,
        message: `War Selection API responded with error [${replayApiResponse.error}]. ` +
        `Original description: ${replayApiResponse.description}`
      };
    }
    
    try {
      const replayApiResponseData = replayApiResponse.data;
      this.#matchData = JSON.parse(replayApiResponseData.extraData["0"]);
      this.#playersLost = replayApiResponseData.extraData["1"] && JSON.parse(replayApiResponseData.extraData["1"]);
      this.#timeLine = replayApiResponseData.extraData["2"] && JSON.parse(replayApiResponseData.extraData["2"]);
      this.#stats = replayApiResponseData.extraData["3"] && JSON.parse(replayApiResponseData.extraData["3"]);
      this.#researches = replayApiResponseData.extraData["4"] && JSON.parse(replayApiResponseData.extraData["4"]);
      this.#initData = replayApiResponseData.initData;
      this.#scriptParameters = this.#parseScriptParams(replayApiResponseData.initData.scriptParameters);

      this.#factionTeams = this.#generateTeamsMap();
      this.#playerSurvival = this.#generateSurvivalMap();
      this.#addWinnersData();
      this.#isWonderWin = this.#getIsWonderWin();

      const players = this.#parsePlayers();
      const teams = this.#parseTeams();
      const match = this.#parseMatch();

      return {
        error: 0,
        players: players,
        teams: teams,
        match: match
      };
    } catch (error) {
      console.error(error);
      return {
        error: 255,
        message: "Cannot parse replay data. Error: " + error.message
      };
    }
  }

  #parseMatch() {
    const match = new Match();
    match.startTime = this.#start;
    match.duration = this.#matchData.duration;
    match.mode = MatchType.fromId(this.#matchData.mode);
    match.winnerTeams = Array.from(this.#teamWinners.keys());
    match.playersCount = this.#matchData.players;
    match.factionsCount = this.#initData.factions;
    match.region = this.#matchData.region;
    match.gameVersion = this.#version;
    match.matchSeed = this.#initData.seed;
    match.creator = this.#scriptParameters.creator;
    match.isMatchmaking = this.#scriptParameters.matchmaking;
    match.isDevMode = this.#scriptParameters.devMode;
    match.isWonderWin = this.#isWonderWin;
    return match;
  }

  #parseTeams() {
    const teamData = this.#initData.teams;
    const teamList = [];
    teamData.forEach((teamFactions, teamId) => {
      const team = new Team();
      teamList.push(team);

      team.id = teamId;
      team.factions = teamFactions;
      team.players = teamFactions.map((factionId) => this.#getFactionPlayer(factionId)).filter(e => e !== null);
      team.isWinner = this.#teamWinners.has(teamId);
      team.isPlayerTeam = team.players.some(playerId => playerId !== null);
      team.color = TEAM_COLORS[teamId % 2];
    });
    return teamList;
  }

  #parsePlayers() {
    const playerScriptData = JSON.parse(this.#scriptParameters.data).players;
    const playerList = [];
    const playerGroups = new Map();

    const wonderLeaderCandidates = [];
    playerScriptData.forEach((playerScriptEntry, playerId) => {
      const player = new Player();
      playerList[playerId] = player;

      const factionId = this.#getPlayerFaction(playerId);
      player.id = playerId;
      player.factionId = factionId;
      player.nickname = playerScriptEntry.name;
      player.isNicknameAutogenerated = !!playerScriptEntry.anonym;
      player.rating = playerScriptEntry.rating;
      player.team = this.#factionTeams.get(factionId);
      player.group = this.#getPlayerGroup(playerScriptEntry, playerGroups);
      player.survivalTime = this.#playerSurvival.get(playerId);
      player.isWinner = this.#playerWinners.has(playerId);
      player.isDead = this.#winnerSurvivalTime > player.survivalTime;
      player.color = FACTION_COLORS[factionId];
      const researchResult = this.#parsePlayerResearches(factionId);
      player.researches = researchResult.researches;
      player.isWonderBuilt = researchResult.wonderTime ? true : false;
      if (player.isWonderBuilt && player.isWinner && this.#isWonderWin) {
        wonderLeaderCandidates.push({ playerId: playerId, researchTime: researchResult.wonderTime });
      }
      player.lastAgeResearch = researchResult.lastAgeResearch;
      player.isWonderWin = false;
    });

    this.#addWonderLeaders(wonderLeaderCandidates, playerList);
    return playerList;
  }

  #addWinnersData() {
    this.#playerWinners = new Set();
    this.#teamWinners = new Set();
    const winnersBitset = this.#matchData.winners;
    const playersCount = this.#initData.players.length;
    this.#winnerSurvivalTime = -1;
    for (let i = 0; i < playersCount; i++) {
      if ((winnersBitset & (1 << i)) !== 0) {
        const faction = this.#getPlayerFaction(i);
        const team = this.#factionTeams.get(faction);
        const survTime = this.#playerSurvival.get(i) || -1;
        this.#winnerSurvivalTime = Math.max(this.#winnerSurvivalTime, survTime);
        this.#playerWinners.add(i);
        this.#teamWinners.add(team);
      }
    }
  }

  #generateSurvivalMap() {
    const result = new Map();
    const survList = this.#playersLost;
    // check for incomplete replay data
    if (survList) {
      for (let i = 0; i < survList.length; i++) {
        const playerSurvEntry = survList[i];
        const playerId = playerSurvEntry[0];
        const survTime = playerSurvEntry[1];
        result.set(playerId, survTime);
      }
    }
    return result;
  }

  #generateTeamsMap() {
    const result = new Map();
    const teams = this.#initData.teams;
    for (let i = 0; i < teams.length; i++) {
      const team = teams[i];
      for (let j = 0; j < team.length; j++) {
        const factionId = team[j];
        result.set(factionId, i);
      }
    }
    return result;
  }

  #getIsWonderWin() {
    // check for incomplete replay data
    if (this.#winnerSurvivalTime === -1) {
      return false;
    }

    return Array.from(this.#playerSurvival.entries()).some(([playerId, survTime]) => 
      !this.#playerWinners.has(playerId) && this.#winnerSurvivalTime <= survTime
    );
  }

  #getPlayerGroup(playerScriptEntry, playerGroups) {
    if (playerScriptEntry.group !== undefined) {
      let groupId = playerGroups.get(playerScriptEntry.group);
      if (groupId === undefined) {
        groupId = playerGroups.size + 1;
        playerGroups.set(playerScriptEntry.group, groupId);
      }
      return groupId;
    }
  }

  #getFactionPlayer(factionId) {
    const playerBitsets = this.#initData.players;
    for (let i = 0; i < playerBitsets.length; i++) {
      const playerBitset = playerBitsets[i];
      if ((playerBitset & (1 << factionId)) !== 0) {
        return i;
      }
    }
    return null;
  }

  #getPlayerFaction(playerId) {
    const playerBitset = this.#initData.players[playerId];
    return getSetBitPositions(playerBitset)[0];
  }

  // not used
  #getPlayerTeam(playerId) {
    const factionId = this.#getPlayerFaction(playerId);
    return this.#getFactionTeam(factionId);
  }

  // not used
  #getFactionTeam(factionId) {
    return this.#factionTeams.get(factionId);
  }

  #parseScriptParams(scriptParamsString) {
    const regexp = /([a-zA-Z0-9]+)=((?:(?!,[a-zA-Z0-9]).)+)/g;
    const matches = scriptParamsString.matchAll(regexp);
    const result = {};
    for (const match of matches) {
      result[match[1]] = match[2];
    }
    return result;
  }

  #parsePlayerResearches(factionId) {
    const researchTimeline = this.#researches?.[factionId];

    // check for incomplete replay data
    if (!researchTimeline) {
      return [];
    }

    const researches = [];
    let lastAgeResearch;
    let wonderTime;
    researchTimeline.forEach((researchEntry) => {
      const time = researchEntry[0];
      const id = researchEntry[1];
      const research = this.#researchesContext[id];

      const playerResearch = new PlayerResearch();
      playerResearch.id = id;
      playerResearch.takenTime = time;
      playerResearch.researchContext = research;
      researches.push(playerResearch);

      if (research.type === "ageTransition") {
        lastAgeResearch = playerResearch;
      }

      if (research.type === "wonderTransition") {
        wonderTime = time;
      }
    });

    return {
      researches: researches,
      lastAgeResearch: lastAgeResearch,
      wonderTime: wonderTime
    };
  }

  #addWonderLeaders(wonderLeaderCandidates, playerList) {
    if (wonderLeaderCandidates.length > 0) {
      // unfortunately there is no way to determine who built the wonder first in case
      // time is the same (it should be extremely rare case), so leaders are multiple
      const wonderLeaders = { time: Number.MAX_VALUE, players: [] };
      wonderLeaderCandidates.forEach((entry) => {
        const time = entry.researchTime;
        // find the very first wonder
        if (wonderLeaders.time > time) {
          wonderLeaders.time = time;
          wonderLeaders.players = [entry.playerId];
        } else if (wonderLeaders.time === time) {
          wonderLeaders.players.push(entry.playerId);
        }
      });

      wonderLeaders.players.forEach((playerId) => {
        playerList[playerId].isWonderWin = true;
      });
    }
  }
}

class Match {
  startTime;
  duration;
  mode;
  winnerTeams;
  playersCount;
  factionsCount;
  region;
  gameVersion;
  matchSeed;
  symmetry;
  creator;
  isMatchmaking;
  isDevMode;
}

class MatchType {
  id;
  type;

  constructor(id, type) {
    this.id = id;
    this.type = type;
  }

  static #values = new Map([
    [0, "FFA"],
    [1, "Team match"],
    [2, "Armageddon"],
    [3, "Survival"],
    [4, "Ranked 1v1"],
    [5, "Ranked 2v2"],
    [6, "Sandbox"],
    [7, "Tug Of War"],
    [8, "Custom Map"],
    [9, "Mafia"],
    [255, "Undefined"]
  ]);

  static fromId(id) {
    const actualId = MatchType.#values.has(id) ? id : 255;
    const type = MatchType.#values.get(actualId);
    return new MatchType(actualId, type);
  }
}

class Team {
  id;
  factions;
  players;
  isWinner;
  isPlayerTeam;
  color;
}

class Player {
  id;
  // assumption that palyer controls only one faction
  // if there will be more - restructuring and complication of data structures is required
  factionId;
  nickname;
  isNicknameAutogenerated;
  rating;
  team;
  group;
  survivalTime;
  isWinner;
  isDead;
  color;
  researches;
  isWonderBuilt;
  isWonderWin;
  lastAgeResearch;
}

class PlayerResearch {
  id;
  takenTime;
  researchContext;
}

function getSetBitPositions(bitset) {
  const result = [];
  for (let i = 0; i < 64; ++i) {
    if ((bitset & (1 << i)) !== 0) {
      result.push(i);
    }
  }
  return result;
}

// taken from WS
const FACTION_COLORS = [
	"#7f7f7f",
	"#dadada",
	"#ff0000",
	"#bfff3f",
	"#00bfff",
	"#ffbf00",
	"#bf007f",
	"#7f00ff",
	"#00ffbf",
	"#ffff00",
	"#ff007f",
	"#00007f",
	"#7fbf7f",
	"#007fff",
	"#ff7f00",
	"#bf00bf",
	"#3fbf00",
	"#bfbf7f",
	"#ffbf7f",
	"#7f0000",
	"#333366",
	"#3fff00",
	"#ffff7f",
	"#ff3f7f",
	"#7f7fff",
	"#7fbf3f",
	"#bf7f00",
	"#ff00ff",
	"#bfbfff",
	"#7fff7f",
	"#ffffbf",
	"#ff7fbf",
	"#3f3fbf",
	"#dfff7f",
	"#ffbfbf",
	"#ff7fff",
	"#3f7fbf",
	"#3f7f3f",
	"#ff7f7f",
	"#bf00ff",
	"#7fbfff",
	"#007f00",
	"#bf7f7f",
	"#7f00bf",
	"#bfffff",
	"#bfbf00",
	"#bf3f3f",
	"#3f003f",
	"#00bfbf",
	"#bf0000",
	"#ffbfff",
	"#00bf7f",
	"#7f3f3f",
	"#7fbfbf",
	"#7f7f00",
	"#3f0000",
	"#bf7fbf",
	"#bfffbf",
	"#7f3f7f",
	"#00ffff",
	"#7fffbf",
	"#007f7f",
	"#7f007f",
	"#0000b3",
	"#bfbfbf"
];

const TEAM_COLORS = [
  "#d97070f7",
  "#69b0dbf7"
];
